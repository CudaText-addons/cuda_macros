''' Plugin for CudaText editorAuthors:    Andrey Kvichansky    (kvichans on githab.com)Version:    '0.8.1 2015-12-04'ToDo: (see end of file)'''import  os, json, randomimport  cudatext        as appfrom    cudatext    import edimport  cudatext_cmd    as cmdsimport  cudax_lib       as apxfrom    cudax_lib   import logpass;                           # Loggingpass;                           LOG = (-2==-2)  # Do or dont logging.JSON_FORMAT_VER = '20151204'MACROS_JSON     = app.app_path(app.APP_DIR_SETTINGS)+os.sep+'macros.json'class Command:    CMD_ID2NM   = {}    # {val: name} from cudatext_cmd.py    macros      = []    # Main list [macro]    mcr4id      = {}    # Derived dict {id:macro}        def __init__(self):        cmd_nms         = [nm                               for nm in dir(cmds)                             if nm.startswith('cCommand_') or nm.startswith('cmd_')]        cmd_nm2id       = {nm:eval('cmds.{}'.format(nm))    for nm in cmd_nms}        self.CMD_ID2NM  = {str(cmd_id):nm                   for nm,cmd_id in cmd_nm2id.items()}        if len(self.CMD_ID2NM) < len(cmd_nm2id):            app.msg_status('Repeated values in cudatext_cmd.py')        pass;                  #LOG and log('cmd_nm2id={}',cmd_nm2id)        pass;                  #LOG and log('CMD_ID2NM={}',self.CMD_ID2NM)                ver_macros      = apx._json_loads(open(MACROS_JSON).read()) if os.path.exists(MACROS_JSON) else {'ver':JSON_FORMAT_VER, 'list':[]}        if ver_macros['ver'] < JSON_FORMAT_VER:            # Adapt to new format            pass        self.macros     = ver_macros['list']        self.mcr4id     = {str(mcr['id']):mcr for mcr in self.macros}       #def __init__           def _rec2evl(self, rec_data):        ''' Coverting from record data to list of API command            Param                rec_data    "\n"-separated list of                                number                                number,string                                py:string_module,string_method,string_param        '''        evls    = []        rcs     = rec_data.splitlines()        for rc in rcs:            if False:pass            elif rc[0] in '0123456789':                if rc in self.CMD_ID2NM:                    # For ed.cmd(id)                    evls += ['ed.cmd(cmds.{})'.format(self.CMD_ID2NM[rc])]                    continue #for rc                if ',' in rc:                    (id_cmd                    ,tx_cmd)= rc[0:rc.index(',')], rc[1+rc.index(','):]                    if ''==id_cmd.strip('0123456789') and id_cmd in self.CMD_ID2NM:                        # For ed.cmd(id, text)                        evls += ["ed.cmd(cmds.{},{})".format(self.CMD_ID2NM[id_cmd], repr(tx_cmd))]                        continue #for rc            elif rc.startswith('py:cuda_macros,dlg_config'):                # Skip macro-tools                continue #for rc            elif rc[0:3]=='py:':                # Plugin cmd                evls += ["app.app_proc(app.PROC_EXEC_PLUGIN, '{}')".format(rc[3:])]                continue #for rc            pass;               LOG and log('unknown rec-item: {}',rc)        return evls       #def _rec2evl    def dlg_config(self):        ''' Show dlg for change macros list.        '''#       macros  = self.macros        all_acts= ['Run macro...'                  ,'View macro actions...'                  ,'Delete macro...'                  ,'Rename macro...'                  ,'-----'                  ,'Cancel record'                  ,'Stop record'                  ,'Start record'                  ]        while True:            acts    = all_acts if 0!=len(self.macros) else all_acts[5:]            act_ind = app.dlg_menu(app.MENU_LIST, '\n'.join(acts))            if act_ind is None or acts[act_ind][0]=='-': return            act     = acts[act_ind]            act     = act[:(act+' ').index(' ')]    # first word            if act in 'Start Stop Cancel':                if False:pass                elif act=='Start'                       and not ed.get_prop(app.PROP_MACRO_REC):                     return ed.cmd(cmds.cmd_MacroStart)                elif act=='Stop'                        and     ed.get_prop(app.PROP_MACRO_REC):                    return ed.cmd(cmds.cmd_MacroStop)                elif act=='Cancel'                      and     ed.get_prop(app.PROP_MACRO_REC):                    return ed.cmd(cmds.cmd_MacroCancel)                return                                keys_json   = app.app_path(app.APP_DIR_SETTINGS)+os.sep+'keys.json'            keys        = apx._json_loads(open(keys_json).read()) if os.path.exists(keys_json) else {}            nms     = []            for mcr in self.macros:                mcr_key = 'cuda_macros,run,{}'.format(mcr['id'])                mcr_keys= keys.get(mcr_key, {})                nms    += ['{}\t{}'.format(                            mcr['nm']                           ,'/'.join([' * '.join(mcr_keys.get('s1', []))                                     ,' * '.join(mcr_keys.get('s2', []))                                     ])                           )]#           if 0==len(nms):#               return            mcr     = ''            if 1==len(nms):                mcr_ind = 0            else:                mcr_ind = app.dlg_menu(app.MENU_LIST, '\n'.join(nms))                if mcr_ind is None: continue # while            mcr     = self.macros[mcr_ind]            what    = ''                    if False:pass            elif act=='Rename':                 #Rename                nms         = [mcr['nm'] for mcr in self.macros]                mcr_nm      = app.dlg_input('New name for: {}'.format(nms[mcr_ind]), mcr['nm'])                if mcr_nm is None or mcr_nm==mcr['nm']:   continue # while                while mcr_nm in nms:                    app.msg_box('Select other name.\nMacro names now are:\n\n'+'\n'.join(nms), app.MB_OK)                    mcr_nm  = app.dlg_input('New name for: {}'.format(nms[mcr_ind]), mcr['nm'])                    if mcr_nm is None or mcr_nm==mcr['nm']:   break # while mcr_nm                if mcr_nm is None or mcr_nm==mcr['nm']:   continue # while                what        = 'rename'                mcr['nm']   = mcr_nm            elif act=='Delete':                 #Delete                if app.msg_box( 'Delete macro\n    {}'.format(nms[mcr_ind]), app.MB_YESNO)!=app.ID_YES: continue # while                what    = 'delete:'+str(mcr['id'])                del self.macros[mcr_ind]            elif act=='View':                 #View                app.msg_box('Actions for macro\n    {}\n\n{}'.format(nms[mcr_ind].expandtabs(8), '\n'.join(mcr['evl']))                            ,app.MB_OK)                return            elif act=='Run':                 return self.run(mcr['id'])            self.when_changed(what)            break #while           #while       #def dlg_config           def on_macro(self, ed_self, mcr_record):        ''' Finish for macro-recording.            Params                mcr_record   "\n"-separated list of                                number                                number,string                                py:string_module,string_method,string_param        '''        pass;                   LOG and log('mcr_record={}',mcr_record)        if ''==mcr_record:   return        def_nm      = ''        nms     = [mcr['nm'] for mcr in self.macros]        for num in range(1,1000):            def_nm  = 'Macro{}'.format(num)            if def_nm not in nms:                break #for num        mcr_nm      = app.dlg_input('Name for new macro', def_nm)        while mcr_nm in nms:            if mcr_nm is None:   return            app.msg_box('Select other name.\nMacros names now:\n\n'+'\n'.join(nms), app.MB_OK)            mcr_nm  = app.dlg_input('Name for new macro', mcr_nm)                # Parse        mcr_cmds    = self._rec2evl(mcr_record)                self.macros += [{'id' :random.randint(10000, 99999)     ##?? conflicts?                        ,'nm' :mcr_nm                        ,'rec':mcr_record                        ,'evl':mcr_cmds                        }]        self.when_changed('add')       #def on_macro    def when_changed(self, what=''):        ''' Use new macro list '''        pass;                   LOG and log('what={}',what)        # Save        open(MACROS_JSON, 'w').write(json.dumps({'ver':JSON_FORMAT_VER, 'list':self.macros}, indent=4))                # Secondary data#       self.mcr4nm     = {mcr['nm']:mcr for mcr in self.macros}        self.mcr4id     = {str(mcr['id']):mcr for mcr in self.macros}                # Register new subcommands        reg_subs        = 'cuda_macros;run;{}'.format('\n'.join(                            'macro: {}\t{}'.format(mcr['nm'],mcr['id'])                                 for mcr in self.macros)                            )        pass;                   LOG and log('reg_subs={}',reg_subs)        app.app_proc(app.PROC_SET_SUBCOMMANDS, reg_subs)                # Clear keys.json        if ':' in what:            # Need delete a key 'cuda_macros,run,NNNNN'            mcr_id      = what[1+what.index(':'):]            mcr_key     = 'cuda_macros,run,{}'.format(mcr_id)            keys_json   = app.app_path(app.APP_DIR_SETTINGS)+os.sep+'keys.json'            if not os.path.exists(keys_json): return            keys        = apx._json_loads(open(keys_json).read())            pass;              #LOG and log('??? key={}',mcr_key)            if keys.pop(mcr_key, None) is not None:                pass;          #LOG and log('del key={}',mcr_key)                open(keys_json, 'w').write(json.dumps(keys, indent=2))       #def when_changed    def run(self, mcr_id):        ''' Main (and single way) to run any macro        '''        mcr_id  = str(mcr_id)        pass;                  #LOG and log('mcr_id={}',mcr_id)        mcr     = self.mcr4id.get(str(mcr_id))        if mcr is None:            return app.msg_status('No macros: {}'.format(mcr_id))        cmds4eval   = ';'.join(mcr['evl'])        pass;                   LOG and log('nm, cmds4eval={}',(mcr['nm'], cmds4eval))        exec(cmds4eval)       #def run          #class Command'''ToDo[+][kv-kv][04dec15] Set stable part for run, use free part for name'''